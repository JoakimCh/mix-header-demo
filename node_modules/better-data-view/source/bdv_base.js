/** @module BetterDataView */

function dataToUint8Array(data) {
  let uint8array
  if (data instanceof ArrayBuffer || Array.isArray(data)) {
    uint8array = new Uint8Array(data)
  } else if (data instanceof Buffer) { // Node.js Buffer
    uint8array = new Uint8Array(data.buffer, data.byteOffset, data.length)
  } else if (ArrayBuffer.isView(data)) { // DataView, TypedArray or Node.js Buffer
    uint8array = new Uint8Array(data.buffer, data.byteOffset, data.byteLength)
  } else {
    throw new BetterDataView_Error('Argument is not an ArrayBuffer, TypedArray, DataView or a Node.js Buffer.', 'TYPE_ERROR')
  }
  return uint8array
}

export class BetterDataView_Error extends Error {
  constructor(message, code = 'GENERIC_ERROR') {
    super(message)
    this.code = 'BETTER_DATA_VIEW:'+code.toUpperCase()
  }
}

export class BetterDataView extends DataView {
  /**
   * Create a new BetterDataView which is a DataView that is easier to work with. The most notable improvement is the support for reading and writing objects to/from the view using "object templates" which contains instructions for binary storage of the object.
   * @param {object} bufferOrStream - An ArrayBuffer or an instance of a stream compatible with BetterDataView. Check the documentation for instructions on how to create such a stream.
   * @param {number} [byteOffset] - The byte-offset into the buffer the view should start from, defaults to 0. If viewing a stream, then this is not used.
   * @param {number} [byteLength] - From the byteOffset how far into the buffer the view should have access, defaults to the end of the buffer. If viewing a stream, then this is not used.
   */
  changeStream(newStream) {
    this.stream = newStream
    this.stream.ioBuffer = new Uint8Array(8) // a 64 bit buffer
    this.streamIo = new DataView(this.stream.ioBuffer.buffer)
  }
  constructor(bufferOrStream, byteOffset, byteLength) { // two last are optional
    if (arguments.length > 1 || bufferOrStream instanceof ArrayBuffer) {
      super(...arguments)
    } else if (bufferOrStream instanceof Buffer) { // Node.js Buffer
      // https://nodejs.org/api/buffer.html#buffer_buf_byteoffset
      super(bufferOrStream.buffer, bufferOrStream.byteOffset, bufferOrStream.length)
    } else { // a "stream object" then
      super(new ArrayBuffer) // use a dummy one
      this.stream = bufferOrStream
      this.stream.ioBuffer = new Uint8Array(8) // a 64 bit buffer
      this.streamIo = new DataView(this.stream.ioBuffer.buffer)
    }
    this._rwPos = 0
    this._littleEndian = false // for network protocols and files BE is the norm
    this._pretendToWrite = false // only works for our replacement functions for IO (used by rwObject.js)
    
    // function aliases
    /** read/write string shorthand */
    this.string = this.s
    this.f53 = this.f64

    // convert base functions to if streaming
    if (this.stream) {
      this.getInt8 = async function(byteOffset) {
        await this.stream.readBytes(byteOffset, 1)
        return this.streamIo.getInt8(0)
      }
      this.setInt8 = function(byteOffset, value) {
        this.streamIo.setInt8(0, value)
        return this.stream.writeBytes(byteOffset, 1) // writeBytes might return a promise
      }

      this.getUint8 = async function(byteOffset) {
        await this.stream.readBytes(byteOffset, 1)
        return this.streamIo.getUint8(0)
      }
      this.setUint8 = function(byteOffset, value) {
        this.streamIo.setUint8(0, value)
        return this.stream.writeBytes(byteOffset, 1)
      }

      this.getInt16 = async function(byteOffset, littleEndian) {
        await this.stream.readBytes(byteOffset, 2)
        return this.streamIo.getInt16(0, littleEndian)
      }
      this.setInt16 = function(byteOffset, value, littleEndian) {
        this.streamIo.setInt16(0, value, littleEndian)
        return this.stream.writeBytes(byteOffset, 2)
      }

      this.getUint16 = async function(byteOffset, littleEndian) {
        await this.stream.readBytes(byteOffset, 2)
        return this.streamIo.getUint16(0, littleEndian)
      }
      this.setUint16 = function(byteOffset, value, littleEndian) {
        this.streamIo.setUint16(0, value, littleEndian)
        return this.stream.writeBytes(byteOffset, 2)
      }

      this.getInt32 = async function(byteOffset, littleEndian) {
        await this.stream.readBytes(byteOffset, 4)
        return this.streamIo.getInt32(0, littleEndian)
      }
      this.setInt32 = function(byteOffset, value, littleEndian) {
        this.streamIo.setInt32(0, value, littleEndian)
        return this.stream.writeBytes(byteOffset, 4)
      }

      this.getUint32 = async function(byteOffset, littleEndian) {
        await this.stream.readBytes(byteOffset, 4)
        return this.streamIo.getUint32(0, littleEndian)
      }
      this.setUint32 = function(byteOffset, value, littleEndian) {
        this.streamIo.setUint32(0, value, littleEndian)
        return this.stream.writeBytes(byteOffset, 4)
      }

      this.getFloat32 = async function(byteOffset, littleEndian) {
        await this.stream.readBytes(byteOffset, 4)
        return this.streamIo.getFloat32(0, littleEndian)
      }
      this.setFloat32 = function(byteOffset, value, littleEndian) {
        this.streamIo.setFloat32(0, value, littleEndian)
        return this.stream.writeBytes(byteOffset, 4)
      }

      this.getFloat64 = async function(byteOffset, littleEndian) {
        await this.stream.readBytes(byteOffset, 4)
        return this.streamIo.getFloat64(0, littleEndian)
      }
      this.setFloat64 = function(byteOffset, value, littleEndian) {
        this.streamIo.setFloat64(0, value, littleEndian)
        return this.stream.writeBytes(byteOffset, 4)
      }

      this.getBigInt64 = async function(byteOffset, littleEndian) {
        await this.stream.readBytes(byteOffset, 8)
        return this.streamIo.getBigInt64(0, littleEndian)
      }
      this.setBigInt64 = function(byteOffset, value, littleEndian) {
        this.streamIo.setBigInt64(0, value, littleEndian)
        return this.stream.writeBytes(byteOffset, 8)
      }

      this.getBigUint64 = async function(byteOffset, littleEndian) {
        await this.stream.readBytes(byteOffset, 8)
        return this.streamIo.getBigUint64(0, littleEndian)
      }
      this.setBigUint64 = function(byteOffset, value, littleEndian) {
        this.streamIo.setBigUint64(0, value, littleEndian)
        return this.stream.writeBytes(byteOffset, 8)
      }
    }
  }
  /**
   * Set the byte endianness to be used for reading and writing (of multi-byte values) from now on.
   * @param {boolean} littleEndian - If this is false then big endianness is used.
   */
  setByteEndianness(littleEndian) {
    this._littleEndian = littleEndian
  }
  /** The byte offset in the DataView (where the next read or write operation will take place). */
  set pos(newPos) {
    this._rwPos = newPos
  }
  get pos() {
    return this._rwPos
  }
  /**
   * Set the byte offset in the DataView (where the next read or write operation will take place).
   * @param {number} byteOffset 
   */
  seek(byteOffset) {
    this._rwPos = byteOffset
  }
  /**
   * A relative seek operation meaning a byteOffset of -4 will seek back 4 bytes from the current position.
   * @param {number} byteOffset 
   */
  rseek(byteOffset) {
    this._rwPos += byteOffset
  }
  /** Set the byte offset in the DataView back to the start. */
  seekStart() {
    this._rwPos = 0
  }
  /** Set the byte offset in the DataView to the end. Nothing can be read or written there, but using rseek() afterwards to do a relative seek back into the buffer could be useful. */
  seekEnd() {
    if (this.stream) throw new BetterDataView_Error('Can not seek to end of a stream (a stream has no end, it\'s either open or closed).', 'STREAM_INCOMPATIBLE')
    this._rwPos = this.byteLength-1
  }
  /**
   * Get a copy of the data from the start of the DataView until its current position. This is not possible is connected to a stream.
   * @param {'BetterDataView'|'ArrayBuffer'|'Uint8Array'|'Buffer'} [returnType] - Which data-container to return. It defaults to a new DataView (not a BetterDataView), but can be set to 'BetterDataView', 'ArrayBuffer', 'Uint8Array' or 'Buffer'. The latter one returns a Node.js Buffer object and can not be used in the browser.
   */
  dataUntilPos(returnType='dataview') {
    if (this.stream) throw new BetterDataView_Error('Incompatible with streams.', 'STREAM_INCOMPATIBLE')
    switch (returnType.toLowerCase()) {
      case 'dataview':
        return new DataView(this.buffer, this.byteOffset, this._rwPos)
      case 'betterdataview':
        return new BetterDataView(this.buffer, this.byteOffset, this._rwPos)
      case 'arraybuffer':
        return this.buffer.slice(this.byteOffset, this.byteOffset+this._rwPos)
      case 'uint8array':
        return new Uint8Array(this.buffer, this.byteOffset, this._rwPos)
      case 'buffer': // Node.js's buffer object
        return Buffer.from(this.buffer.slice(this.byteOffset, this.byteOffset+this._rwPos))
    }
  }
  /**
   * Read or write a signed byte (-128 to 127).
   * @param {number} [value] If specified then the value is written, else a value is read.
   */
  i8(value) {
    const byteOffset = this._rwPos; this._rwPos += 1
    if (value !== undefined)
      if (!this._pretendToWrite) return this.setInt8(byteOffset, value)
    return this.getInt8(byteOffset)
  }
  /**
   * Read or write an unsigned byte (0 to 255).
   * @param {number} [value] If specified then the value is written, else a value is read.
   */
  u8(value) {
    const byteOffset = this._rwPos; this._rwPos += 1
    if (value !== undefined)
      if (!this._pretendToWrite) return this.setUint8(byteOffset, value)
    return this.getUint8(byteOffset)
  }
  /**
   * Read or write a 2-byte signed integer (-32,768 to 32,767).
   * @param {number} [value] If specified then the value is written, else a value is read.
   */
  i16(value) {
    const byteOffset = this._rwPos; this._rwPos += 2
    if (value !== undefined)
      if (!this._pretendToWrite) return this.setInt16(byteOffset, value, this._littleEndian)
    return this.getInt16(byteOffset, this._littleEndian)
  }
  /**
   * Read or write a 2-byte unsigned integer (0 to 65,535).
   * @param {number} [value] If specified then the value is written, else a value is read.
   */
  u16(value) {
    const byteOffset = this._rwPos; this._rwPos += 2
    if (value !== undefined)
      if (!this._pretendToWrite) return this.setUint16(byteOffset, value, this._littleEndian)
    return this.getUint16(byteOffset, this._littleEndian)
  }
  /**
   * Read or write a 4-byte signed integer (-2,147,483,648 to 2,147,483,647).
   * @param {number} [value] If specified then the value is written, else a value is read.
   */
  i32(value) {
    const byteOffset = this._rwPos; this._rwPos += 4
    if (value !== undefined)
      if (!this._pretendToWrite) return this.setInt32(byteOffset, value, this._littleEndian)
    return this.getInt32(byteOffset, this._littleEndian)
  }
  /**
   * Read or write a 4-byte unsigned integer (0 to 4,294,967,295).
   * @param {number} [value] If specified then the value is written, else a value is read.
   */
  u32(value) {
    const byteOffset = this._rwPos; this._rwPos += 4
    if (value !== undefined)
      if (!this._pretendToWrite) return this.setUint32(byteOffset, value, this._littleEndian)
    return this.getUint32(byteOffset, this._littleEndian)
  }
  /**
   * Read or write a 4-byte single-precision floating-point IEEE 754) number (-3.4E+38 to +3.4E+38) with an accuracy of about 7 decimal digits.
   * @param {number} [value] If specified then the value is written, else a value is read.
   */
  f32(value) {
    const byteOffset = this._rwPos; this._rwPos += 4
    if (value !== undefined)
      if (!this._pretendToWrite) return this.setFloat32(byteOffset, value, this._littleEndian)
    return this.getFloat32(byteOffset, this._littleEndian)
  }
  /**
   * Read or write an 8-byte double-precision floating-point (IEEE 754) number (-1.7E+308 to +1.7E+308) with an accuracy of about 16 decimal digits. Or a signed integer up to 53-bits (+-9,007,199,254,740,991), e.g. Number.MAX_SAFE_INTEGER.
   * @param {number} [value] If specified then the value is written, else a value is read.
   */
  f64(value) {
    const byteOffset = this._rwPos; this._rwPos += 8  
    if (value !== undefined)
      if (!this._pretendToWrite) return this.setFloat64(byteOffset, value, this._littleEndian)
    return this.getFloat64(byteOffset, this._littleEndian)
  }
  /**
   * Read or write an 8-byte signed integer (-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807).
   * @param {bigint} [value] If specified then the value is written, else a value is read.
   */
  i64(value) {
    const byteOffset = this._rwPos; this._rwPos += 8
    if (value !== undefined)
      if (!this._pretendToWrite) return this.setBigInt64(byteOffset, value, this._littleEndian)
    return this.getBigInt64(byteOffset, this._littleEndian)
  }
  /**
   * Read or write an 8-byte unsigned integer (0 to 18,446,744,073,709,551,615).
   * @param {bigint} [value] If specified then the value is written, else a value is read.
   */
  u64(value) {
    const byteOffset = this._rwPos; this._rwPos += 8
    if (value !== undefined)
      if (!this._pretendToWrite) return this.setBigUint64(byteOffset, value, this._littleEndian)
    return this.getBigUint64(byteOffset, this._littleEndian)
  }
  /**
   * Read or write a UTF-8 compatible string. A shorthand of readString / writeString, to support other encodings use those instead.
   * 
   * Since the VS Code's JSDoc parser doesn't understand overloads (defined using JSDoc syntax) I have to describe them here...
   * 
   * - No parameter: Read a zero-terminated string.
   * - One parameter (number): Read a string until this character length.
   * - One parameter (string): Write a zero-terminated string.
   * - Two parameters (string, number): Write a string of this length.
   * - Two parameters (string, boolean): Write the whole string and zero-terminate it if the boolean is true.
   */
  s() {
    switch (arguments.length) {
      case 0:
        return this.readString()
      case 1:
        if (typeof arguments[0] == 'number')
          return this.readString(arguments[0])
        else
          return this.writeString(arguments[0])
      case 2:
        switch (typeof arguments[1]) {
          case 'boolean': // with or without zero
          return this.writeString(arguments[0], arguments[1])
          case 'number': { // cap string length or maybe just throw an error
            const strLength = [...arguments[0]].length // get proper length of strings with multi-byte characters
            const charsToWrite = arguments[1]
            if (strLength > charsToWrite) {
              throw new BetterDataView_Error(`Asked to write a shorter (${charsToWrite}) string than the one provided (${strLength}): `+arguments[0], 'SIZE_MISMATCH')
              // const string = [...arguments[0]].slice(0, charsToWrite).join('') // this is how we must cap a unicode string, sadly...
              // return this.writeString(string, false)
            } else if (strLength < charsToWrite) {
              throw new BetterDataView_Error(`Asked to write a longer (${charsToWrite}) string than the one provided (${strLength}): `+arguments[0], 'SIZE_MISMATCH')
            } else {
              return this.writeString(arguments[0], false)
            }
          }
          default: throw new BetterDataView_Error('Invalid second argument for string write: '+typeof arguments[1], 'TYPE_ERROR')
        }
    }
  }
  /**
   * Read a string of the selected encoding (UTF-8 by default). Any length specified must be the number of characters to read, else if undefined it will read until the string is zero-terminated. For a list of supported encodings just check what's supported by TextDecoder in your environment, but independently of that it will always support unicode of any kind (UTF-8/16/32 BE/LE).
   * @param {number} [length] A length of 0 will return an empty string. If undefined read until a zero-termination of the string.
   * @param {string} [encoding] Defaults to UTF-8. Example of other encoding: 'UTF-16LE'.
   */
  async readString(length, encoding = 'UTF-8') {
    if (length === 0) return ''
    let text = '', charactersRead = 0
    // for fun and as an educational example I do my own decoding of the Unicode formats
    switch (encoding.toLowerCase()) {
      case 'utf-8': case 'utf8': case 'unicode-1-1-utf-8': {
        let bytesLeftInSequence = -1, utf32, sequencePos
        while (!this.stream?.closed) {
          if (!this.stream && this._rwPos >= this.byteLength) throw new BetterDataView_Error('DataView position out of bounds...', 'OUT_OF_BOUNDS')
          const byte = await this.u8()
          if (bytesLeftInSequence < 0) {
            sequencePos = 0
            if (byte == 0) {
              if (length) { // 0 byte is only allowed when length was not specified
                throw new BetterDataView_Error('Encountered a zero byte in the '+encoding+' string before the wanted length ('+length+') was read. The string so far: '+text, 'STRING_ERROR')
              }
              break // we're done
            } else if (!(byte & 0b1000_0000) /*bit.isNotSet(byte, 7)*/) {
              bytesLeftInSequence = 0
              utf32 = byte
            } else if (byte >> 5 == 0b110) {
              utf32 = (byte & 0b0001_1111) << 6
              bytesLeftInSequence = 1
            } else if (byte >> 4 == 0b1110) {
              utf32 = (byte & 0b0000_1111) << 12
              bytesLeftInSequence = 2
            } else if (byte >> 3 == 0b11110) {
              utf32 = (byte & 0b0000_0111) << 18
              bytesLeftInSequence = 3
            } else {
              throw new BetterDataView_Error('Invalid byte in the '+encoding+' sequence: '+bin(byte)+'. The string so far: '+text, 'STRING_ERROR')
            }
          } else if (byte >> 6 != 0b10) {
            throw new BetterDataView_Error('Invalid byte in the '+encoding+' sequence: '+bin(byte)+'. The string so far: '+text, 'STRING_ERROR')
          }
          if (sequencePos != 0) {
            utf32 |= (byte & 0b0011_1111) << (6 * bytesLeftInSequence)
          }
          if (bytesLeftInSequence == 0) {
            try {text += String.fromCodePoint(utf32)}
            catch {throw new BetterDataView_Error('The '+encoding+' sequence held an invalid codepoint. The string so far: '+text, 'STRING_ERROR')}
            if (++charactersRead == length) break // we're done
          }
          bytesLeftInSequence --
          sequencePos ++
        }
        return text
      }
      case 'utf-16': case 'utf-16be': case 'utf-16le': case 'ucs-2': case 'ucs-2be': case 'ucs-2le': {
        const littleEndianWas = this._littleEndian
        // the unmarked form uses big-endian byte serialization by default
        switch (encoding.slice(-2).toLowerCase()) {
          case 'le': this._littleEndian = true; break
          case 'be': default: this._littleEndian = false; break
        }
        let surrogatePair, current, previous
        try {while (!this.stream?.closed) {
          if (!this.stream && this._rwPos >= this.byteLength) throw new BetterDataView_Error('DataView position out of bounds...', 'OUT_OF_BOUNDS')
          current = await this.u16() // reads the value with the set endianess (returns it as little endian)
          if (current == 0) {
            if (length) { // 0 is only allowed when length was not specified
              throw new BetterDataView_Error('Encountered a zero value in the '+encoding+' string before the wanted length ('+length+') was read. The string so far: '+text, 'STRING_ERROR')
            }
            break
          }
          if (current == 0b1111_1111_1111_1110) { // this is a BOM (byte order mark) read in reverse (indicating wrong byte order)
            if (this._littleEndian == true) {
              console.warn('UTF-16 BOM corrected the byte order to BE.')
              this._littleEndian = false
            } else {
              console.warn('UTF-16 BOM corrected the byte order to LE.')
              this._littleEndian = true
            }
          } else if (current == 0b1111_1110_1111_1111) { // a BOM indicating correct byte order
            // ignore it
          } else if (!surrogatePair) {
            if ((current & 0b1111_1100_0000_0000) == 0b1101_1000_0000_0000) { // start of pair
              surrogatePair = true
            } else {
              try {text += String.fromCodePoint(current)} // text += String.fromCharCode(current)
              catch {throw new BetterDataView_Error('The '+encoding+' sequence held an invalid codepoint. The string so far: '+text, 'STRING_ERROR')}
              charactersRead ++
            }
          } else { // second part of pair
            surrogatePair = false
            if ((current & 0b1111_1100_0000_0000) == 0b1101_1100_0000_0000) { // end of pair
              let codePoint
              codePoint = (previous & 0b0000_0011_1111_1111) << 10;
              codePoint |= (current & 0b0000_0011_1111_1111)
              codePoint += 0b1_0000_0000_0000_0000
              try {text += String.fromCodePoint(codePoint)} // text += String.fromCharCode(previous, current)
              catch {throw new BetterDataView_Error('The '+encoding+' sequence held an invalid codepoint. The string so far: '+text, 'STRING_ERROR')}
              charactersRead ++
            } else {
              throw new BetterDataView_Error('Invalid bytes in the '+encoding+' sequence: '+bin(current | (previous << 16), 32)+'. The string so far: '+text, 'STRING_ERROR')
            }
          }
          if (charactersRead == length) break
          previous = current
        }} finally { // restore in case throw is caught and also before return
          this._littleEndian = littleEndianWas
        }
        return text
      }
      case 'utf-32': case 'utf-32be': case 'utf-32le': case 'ucs-4': case 'ucs-4be': case 'ucs-4le': {
        // this one is easy
        const littleEndianWas = this._littleEndian
        switch (encoding.slice(-2).toLowerCase()) {
          case 'le': this._littleEndian = true; break
          case 'be': default: this._littleEndian = false; break
        }
        while (!this.stream?.closed) {
          if (!this.stream && this._rwPos >= this.byteLength) throw new BetterDataView_Error('DataView position out of bounds...', 'OUT_OF_BOUNDS')
          const utf32 = await this.u32()
          if (utf32 == 0) {
            if (length) { // 0 is only allowed when length was not specified
              throw new BetterDataView_Error('Encountered a zero value in the '+encoding+' string before the wanted length ('+length+') was read. The string so far: '+text, 'STRING_ERROR')
            }
            break
          }
          if (utf32 == 0xFFFE_0000) { // this is a BOM (byte order mark) read in reverse (indicating wrong byte order)
            if (this._littleEndian == true) {
              console.warn('UTF-32 BOM corrected the byte order to BE.')
              this._littleEndian = false
            } else {
              console.warn('UTF-32 BOM corrected the byte order to LE.')
              this._littleEndian = true
            }
          } else if (utf32 == 0x0000_FEFF) { // a BOM indicating correct byte order
            // ignore it
          } else {
            try {text += String.fromCodePoint(utf32)}
            catch {throw new BetterDataView_Error('The '+encoding+' sequence held an invalid codepoint. The string so far: '+text, 'STRING_ERROR')}
            charactersRead ++
            if (charactersRead == length) break
          }
        }
        this._littleEndian = littleEndianWas
        return text
      }
      default: {
        const textDecoder = new TextDecoder(encoding, {fatal: true})
        while (!this.stream?.closed) {
          if (!this.stream && this._rwPos >= this.byteLength) throw new BetterDataView_Error('DataView position out of bounds...', 'OUT_OF_BOUNDS')
          const byte = await this.u8()
          if (byte == 0 && length == undefined) break // zero termination
          text += textDecoder.decode(new Uint8Array([byte].buffer), {stream:true})
          if ([...text].length >= length) break
        }
        return text
      }
    }
  }
  /**
   * Write a string of the selected encoding (UTF-8 by default). For a list of supported encodings just check what's supported by TextDecoder in your environment, but independently of that it will always support unicode of any kind (UTF-8/16/32 BE/LE).
   * @param {string} [string] The string to write, an undefined string will still be zero-terminated if zeroTerminated is true. 
   * @param {boolean} [zeroTerminated] Whether to zero-terminate the string or not.
   * @param {string} [encoding] Defaults to UTF-8. Example of other encoding: 'UTF-16LE'.
   */
  async writeString(string, zeroTerminated=true, encoding = 'UTF-8') {
    switch (encoding.toLowerCase()) {
      case 'utf-8': case 'utf8': case 'unicode-1-1-utf-8': {
        if (string) {
          for (const char of [...string]) {
            const utf32 = char.codePointAt(0)
            if (utf32 < 0x0080) { // fits in 1 byte
              this.u8(utf32)
            } else if (utf32 < 0x0800) { // 2
              this.u8(0b1100_0000 | (utf32 >>  6) & 0b0001_1111)
              this.u8(0b1000_0000 |  utf32        & 0b0011_1111)
            } else if (utf32 < 0x10000) { // 3
              this.u8(0b1110_0000 | (utf32 >> 12) & 0b0000_1111)
              this.u8(0b1000_0000 | (utf32 >>  6) & 0b0011_1111)
              this.u8(0b1000_0000 |  utf32        & 0b0011_1111)
            } else if (utf32 <= 0x10FFFF) { // more than 3
              this.u8(0b1111_0000 | (utf32 >> 18) & 0b0000_0111)
              this.u8(0b1000_0000 | (utf32 >> 12) & 0b0011_1111)
              this.u8(0b1000_0000 | (utf32 >>  6) & 0b0011_1111)
              this.u8(0b1000_0000 |  utf32        & 0b0011_1111)
            } else {
              throw new BetterDataView_Error('Tried to UTF-8 encode this invalid codepoint: '+utf32, 'STRING_ERROR')
            }
          }
        }
        if (zeroTerminated) this.u8(0)
        return
      }
      case 'utf-16': case 'utf-16be': case 'utf-16le': case 'ucs-2': case 'ucs-2be': case 'ucs-2le': {
        const littleEndianWas = this._littleEndian
        // the unmarked form uses big-endian byte serialization by default
        switch (encoding.slice(-2).toLowerCase()) {
          case 'le': this._littleEndian = true; break
          case 'be': default: this._littleEndian = false; break
        }
        if (string) {
          for (const char of [...string]) {
            let utf32 = char.codePointAt(0)
            if (utf32 <= 0xD7FF || (utf32 >= 0xE000 && utf32 <= 0xFFFF)) { // if it fits in 2 bytes
              this.u16(utf32)
            } else if (utf32 >= 0x010000 && utf32 <= 0x10FFFF) {
              utf32 -= 0b1_0000_0000_0000_0000
              let a = 0b1101_1000_0000_0000, b = 0b1101_1100_0000_0000 // surrogate pair start and end bits
              b |= utf32 & 0b11_1111_1111 // get 10 of the rightmost bits
              a |= utf32 >> 10 // and the rest 10 bits
              this.u16(a)
              this.u16(b)
            } else { // should not really happen with a JS string?
              this._littleEndian = littleEndianWas // restore in case throw is caught
              throw new BetterDataView_Error('Tried to UTF-16 encode this invalid codepoint: '+utf32, 'STRING_ERROR')
            }
          }
        }
        if (zeroTerminated) this.u16(0)
        this._littleEndian = littleEndianWas
        return
      }
      case 'utf-32': case 'utf-32be': case 'utf-32le': case 'ucs-4': case 'ucs-4be': case 'ucs-4le': {
        const littleEndianWas = this._littleEndian
        switch (encoding.slice(-2).toLowerCase()) {
          case 'le': this._littleEndian = true; break
          case 'be': default: this._littleEndian = false; break // the unmarked form uses big-endian byte serialization by default
        }
        if (string) {
          for (const char of [...string]) {
            this.u32(char.codePointAt(0))
          }
        }
        if (zeroTerminated) this.u32(0)
        this._littleEndian = littleEndianWas
        return
      }
      default: {
        const bytes = new TextEncoder(encoding).encode(string) // returns Uint8Array
        for (const byte of bytes) await this.u8(byte)
        if (zeroTerminated) await this.u8(0)
        return
      }
    }
  }
  /**
   * Write the bytes of any ArrayBuffer, TypedArray or DataView.
   * @param {object} data ArrayBuffer, TypedArray or DataView.
   * @param {number} [length] The number of bytes to write, defaults to the buffer size.
   */
  async writeBytes(data, length) {
    const byteArray = dataToUint8Array(data)
    if (!length)
      length = byteArray.length
    else if (length > byteArray.length)
      throw new BetterDataView_Error('A length of '+length+' specified, but only '+byteArray.length+' bytes available', 'SIZE_MISMATCH')
    for (let i=0; i<length; i++) {
      await this.u8(byteArray[i])
    }
  }
  /**
   * Read the specified length of bytes into an ArrayBuffer.
   * @param {number} [length] The number of bytes to read. If not specified then it will read until the end of the internal buffer or if using a stream it will read until the stream is closed.
   */
  async readBytes(length, returnUint8Array) {
    if (length === 0) return new ArrayBuffer()
    if (!this.stream) {
      if (length == undefined) { // read until end then
        length = this.byteLength - this._rwPos
      }
      // when slicing to create a new buffer we need to have in mind that the part of the buffer we are "viewing" might be sized smaller than the size of the buffer and might also have an offset
      if (this._rwPos + length > this.byteLength)
        throw new BetterDataView_Error('You can not read bytes further than the viewing size of this DataView.')
      const arrayBuffer = this.buffer.slice(
        this.byteOffset+this._rwPos,
        this.byteOffset+this._rwPos + length
      )
      this._rwPos += length
      if (returnUint8Array) return new Uint8Array(arrayBuffer)
      return arrayBuffer
    } else {
      const bytes = []
      while (!this.stream?.closed && bytes.length != length) {
        const byte = await this.u8()
        bytes.push(byte)
      }
      if (returnUint8Array) return new Uint8Array(bytes)
      return new Uint8Array(bytes).buffer
    }
  }
  /**
   * Read or write bytes, a shorthand for readBytes / writeBytes.
   * 
   * Since the VS Code's JSDoc parser doesn't understand overloads (defined using JSDoc syntax) I have to describe them here...
   * 
   * - No parameter: Read bytes until the end of the buffer or the stream is closed.
   * - One parameter (number): Read this amount of bytes.
   * - One parameter (object): Write the bytes of the supplied ArrayBuffer, TypedArray or DataView.
   * - Two parameters (object, length): The same as above but with the length specified.
   */
  bytes() { // write or read bytes
    switch (arguments.length) {
      case 0:
        return this.readBytes()
      case 1:
        if (typeof arguments[0] == 'number')
          return this.readBytes(arguments[0])
        else {
          return this.writeBytes(arguments[0])
        }
      case 2:
        return this.writeBytes(arguments[0], arguments[1])
    }
  }
  /**
   * Write a Date object into a 32 or 64 bit integer depending on whether to keep the millisecond precision. This is compatible with "Unix time" (also called "Epoch time"). Actually it can only use 53 bits of the 64 bits (see Number.MAX_SAFE_INTEGER).
   * @param {object} date The Date object which contains the timestamp.
   * @param {boolean} [includeMilliseconds] Defaults to false. Writes 32 bits if false, else 64 bits.
   */
  writeTime(date, includeMilliseconds=false) {
    assert_date(date)
    if (includeMilliseconds) return this.f64(date.getTime())
    return this.u32(Math.round(date.getTime()/1000))
  }
  /**
   * Reads a Date object from a 32 or 64 bit integer depending on whether includeMilliseconds is true or false. This is compatible with "Unix time" (also called "Epoch time"). Actually it can only use 53 bits of the 64 bits (see Number.MAX_SAFE_INTEGER).
   * @param {boolean} [includeMilliseconds] Defaults to false. Reads 32 bits if false, else 64 bits.
   */
  async readTime(includeMilliseconds=false) {
    return new Date(includeMilliseconds ? await this.f64() : (await this.u32())*1000.0)
  }
  /**
   * Read or write a Date object to/from a 64 bit integer. A shorthand for readTime / writeTime with the millisecond precision.
   * @param {object} [date] The Date to write or undefined to read a Date. 
   */
  date(date) {
    if (date !== undefined) return this.writeTime(date, true)
    return this.readTime(true)
  }
  /**
   * Read or write a Date object to/from a 32 bit integer. A shorthand for readTime / writeTime without the millisecond precision. Called unixtime because they're often stored as a 32 bit integer. For a 64 bit "Unix time" a JavaScript Date object can currently represent it and you must read/write it using u64 which uses BigInts.
   * @param {object} [unixtime] The Date to write or undefined to read a Date. 
   */
  unixtime(unixtime) {
    if (unixtime !== undefined) return this.writeTime(unixtime)
    return this.readTime()
  }
  /**
   * Read an Array from the DataView of the specified type and dimensions.
   * @param {string} type Using the "object template" syntax. E.g. 'u8' for an array of unsigned bytes.
   * @param  {...number} dim Specify the Array dimensions, e.g. 32, 32 to read a 2D cubic array of size 32.
   * @returns {Promise.<Array>} An Array of the values read.
   * @example
   * // read back a 32-bit icon with a width and height of 32 pixels
   * icon = readArray('u32', 32, 32)
   * rgbaOfFirstPixel = icon[0][0]
   */
  async readArray(type, ...dim) {
    if (dim.length) { // if we should create an empty array
      const array = new Array(dim[0])
      for (let i=0; i<dim[0]; i++) {
        array[i] = await this.readArray(type, ...dim.slice(1))
      }
      return array
    } else { // if we should read a value into the array (used internally in this function)
      if (type.startsWith('s') && type.indexOf(':') != -1) { // if a string with size
        return await this.readString(+type.split(':')[1])
      } else {
        return await this[type]()
      }
    }
  }
  /**
   * Write an Array into the DataView with the specified type.
   * @param {string} type Using the "object template" syntax. E.g. 'u8' for an array of unsigned bytes.
   * @param {array} array The array to write.
   */
  async writeArray(type, array) {
    if (Array.isArray(array)) {
      for (const value of array) {
        await this.writeArray(type, value)
      }
    } else { // then 'array' is the value to write
      const value = array
      if (type.startsWith('s') && type.indexOf(':') != -1) { // if a string with specific size
        const sizeSpecified = +type.split(':')[1]
        if (value.length != sizeSpecified)
          throw new BetterDataView_Error('The string size is different from: '+sizeSpecified, 'SIZE_MISMATCH')
        await this.writeString(value, false)
      } else {
        await this[type](value)
      }
    }
  }
 /**
  * Read or write an IPv4 address. Addresses read will be returned as strings.
  * Addresses written are stored as 4 bytes.
  * @param {(string|number)} [address] Either a string or an integer.
  */
 async ipv4(address) {
    switch (typeof address) {
      default: 
        throw new BetterDataView_Error('Unknown data type for IPv4 address: '+typeof address, 'TYPE_ERROR')
      case 'string': {
        const bytes = this._littleEndian ?
          address.split('.').reverse() :
          address.split('.')
        for (const byte of bytes) await this.u8(byte)
      } return
      case 'number':
        return this.u32(address)
      case 'undefined': { // read
        const bytes = []
        for (let i=0; i<4; i++)
          bytes.push(await this.u8())
        if (this._littleEndian)
          return bytes.reverse().join('.')
        else
          return bytes.join('.')
      }
    }
  }
  /**
  * Read or write an IPv6 address. Addresses read will be returned as strings.
  * Addresses written are stored as 16 bytes.
  * 
  * This function is not completed yet, it lacks support for address compression and endianness.
  * @param {(string)} [address] The address to write as a string.
  */
  //https://chrisgrundemann.com/index.php/2012/introducing-ipv6-understanding-ipv6-addresses/
  async ipv6(address) {
    // Todo: logic for address compression
    // Todo: endianness
    if (address) { // write
      switch (typeof address) {
        case 'string':
          const sections = address.split('.')
          for (const section of sections) await this.u16(section)
        break
        default: throw new BetterDataView_Error('Unknown data type for IPv6 address: '+typeof address, 'TYPE_ERROR')
      }
    } else { // read
      const sections = []
      for (let i=0; i<8; i++) sections.push(await this.u16().toString(16))
      address = bytes.join(':')
      return address
    }
  }
  /**
   * Allows you to write a field of integers less than 8 bits, which is useful for boolean flags and tiny integers.
   * The total amount of bits written will be aligned to the nearest byte. A bit field is not affected by the byte endianness set, it's up to you to keep them in the right order. Unused bits are best to declare as reserved.
   * @param {*} template The bitField template object, see the example for details.
   * @param {*} values The object containing values matching the template.
   * @example
   * await writeBitField({ // the template
   *   responseCode: 3, // 3 bits wide
   *   hasHair: 1, // some flags
   *   hasBeard: 1,
   *   hasGlasses: 1,
   *   reservedBits: 2 // these are unused
   * }, { // the values to write
   *   responseCode: 7, // the number 7
   *   hasHair: true // the number 1
   *   // missing fields are automatically written to 0 / false
   * })
   */
  async writeBitField(template, values) {
    if (typeof template != 'object')
      throw new BetterDataView_Error('A bitfield needs an object defining the bit-size of each value.', 'TYPE_ERROR')
    if (typeof values != 'object')
      throw new BetterDataView_Error('A bitfield needs an object that contains the values to fill it with.', 'TYPE_ERROR')
    const templateArray = Object.entries(template) // [...[key, value]]
    let byte = 0, byteBitIndex = 0
    for (let fieldIndex=0; fieldIndex<templateArray.length; fieldIndex++) {
      const bitSize = templateArray[fieldIndex][1]
      if (bitSize > 8) throw new BetterDataView_Error('A bitField can\'t currently have integers larger than a byte (8 bits).', 'TYPE_ERROR')
      const key = templateArray[fieldIndex][0]
      const value = values[key] ?? 0 // undefined or null value defaults to 0
      if (!Number.isInteger(value) || value < 0) throw new BetterDataView_Error('A value in a bit field can only be a positive integer, not: '+value, 'TYPE_ERROR')
      if (value > maxInteger(bitSize)) throw new BetterDataView_Error(`An integer with ${bitSize} bits can't contain ${value}, the largest number it can hold is ${maxInteger(bitSize)}.`, 'TYPE_ERROR')
      for (let valueBitIndex=0; valueBitIndex<bitSize; valueBitIndex++) {
        if (value >> bitSize-1-valueBitIndex & 1) { // if bit is set
          byte |= 1 << 7-byteBitIndex // set it
        }
        byteBitIndex ++
        if (byteBitIndex > 7) {
          byteBitIndex = 0
          await this.u8(byte)
          byte = 0
        }
      }
    }
    if (byteBitIndex != 0) { // the last byte was not completely filled with bits and has not been written yet
      await this.u8(byte)
    }
  }
  /**
   * Allows you to read a field of integers less than 8 bits, which is useful for boolean flags and tiny integers.
   * The total amount of bits read will be aligned to the nearest byte. A bit field is not affected by the byte endianness set, it's up to you to keep them in the right order. Unused bits are best to declare as reserved.
   * @param {*} template The bitField template object, see the example for details.
   * @return {Promise.<object>} Returns an object with the keys from the template filled with the values read.
   * @example
   * bitField = await readBitField({ // the template
   *   responseCode: 3, // 3 bits wide
   *   hasHair: 1, // some flags
   *   hasBeard: 1,
   *   hasGlasses: 1,
   *   reservedBits: 2 // these are unused
   * })
   * if (bitField.hasBeard) shaveBeard()
   */
  async readBitField(template) {
    if (typeof template != 'object')
      throw new BetterDataView_Error('A bitfield needs an object defining the bit-size of each value.', 'TYPE_ERROR')
    const fieldArray = Object.entries(template) // [...[key, value]]
    let byte, value = 0, byteBitIndex = 0
    for (let fieldIndex=0; fieldIndex < fieldArray.length; fieldIndex++) {
      const bitSize = fieldArray[fieldIndex][1]
      if (!Number.isInteger(bitSize) || bitSize < 0 || bitSize > 8) throw new BetterDataView_Error('The defined bit-size must be a number from 1 to 8, not '+bitSize, 'TEMPLATE_ERROR')
      for (let valueBitIndex = 0; valueBitIndex < bitSize; valueBitIndex ++) {
        if (byteBitIndex == 0) { // then we need to read the next byte
          byte = await this.u8()
        }
        if (byte >> 7-byteBitIndex & 1) { // if bit is set
          value |= 1 << bitSize-1-valueBitIndex // set it here
        }
        if (valueBitIndex == bitSize-1) { // if all bits in value has been written
          fieldArray[fieldIndex][1] = value
          value = 0
        }
        if (++byteBitIndex == 8) byteBitIndex = 0
      }
    }
    return Object.fromEntries(fieldArray)
  }
  /**
   * Read or write DNS strings in a DNS packet. When reading this might jump around in the DataView to reuse parts of the strings already written elsewhere in the packet. And when writing this maintains a string cache so that it can know which parts of the string is already written elsewhere in the packet. Hence if you're going to use the same DataView to write several DNS packets then the string cache needs to be cleared between them, this can be done with dns_clearStringCache().
   * @param {string} string The string to write, probably
   * @param {number} [packetOffset] Optionally used when reading if the DataView contains other data before the DNS packet. Then it needs to know the offset of the start of the DNS packet to be able to resolve any compressed strings.
   */
  async dns_string(string, packetOffset = 0) {
    if (string === undefined) { // read string
      string = ''
      do {
        const byte = await this.u8()
        if (byte == 0) break
        if (string.length) string += '.'
        if (byte >= 0b1100_0000) { // if first two bits are set
          let packetIndex = (byte ^ 0b1100_0000) << 8
          packetIndex |= await this.u8()
          const pPos = this._rwPos // save pos
          this._rwPos = packetOffset + packetIndex // jump to pos in index
          string += await this.dns_string() // read it
          this._rwPos = pPos // restore pos
          break
        } else {
          const length = byte
          string += await this.readString(length)
        }
      } while (1)
      return string
    } else { // write string
      string = string.toLowerCase()
      if (this.strCache === undefined)
        this.strCache = new Map()
      const updateCache = (string, pos) => {
        if (!this.strCache.has(string)) {
          this.strCache.set(string, pos)
          //log(pos, string)
        }
      }
      const writeLabels = async (labelArr, strArr) => {
        const tmpArr = Array.from(labelArr) // copies it
        for (const label of labelArr) {
          updateCache([...tmpArr, ...strArr].join('.'), this._rwPos)
          tmpArr.shift()
          await this.u8(label.length)
          await this.s(label, false)
        }
      }
      const strArr = string.split('.')
      const labelArr = []
      let i, packetIndex, labelCount = strArr.length
      for (i=0; i<labelCount; i++) {
        packetIndex = this.strCache.get(strArr.join('.'))
        if (packetIndex) break
        labelArr.push(strArr.shift())
      }
      if (packetIndex) { // if previously written
        if (i) // but not the whole part
          await writeLabels(labelArr, strArr)
        packetIndex |= 0b1100_0000 << 8
        await this.u16(packetIndex) // write pointer
      } else { // no parts previously written
        await writeLabels(labelArr, strArr)
        await this.u8(0) // then put a zero
      }
    }
  }
  /**
   * Clear the DNS string cache used to correctly compress strings in a DNS packet. This should be done if the same DataView is used to write several DNS packets.
   */
  dns_clearStringCache() {
    this.strCache = undefined //delete this.strCache
    // then the garbage collector will free the map
  }
}

function assert_date(date) {
  if(!(date instanceof Date/* Object.prototype.toString.call(date) === "[object Date]" */ && !isNaN(date)))
    throw new BetterDataView_Error('This is not a date object with a valid date: '+date, 'TYPE_ERROR')
}
function bin(val, numBits=8) { // output binary from value
  const bin = val.toString(2)
  return '0'.repeat(numBits-bin.length)+bin
}
function maxInteger(numBits) {
  return (2**numBits)-1
}
