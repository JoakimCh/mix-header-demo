

import {BetterDataView as BetterDataView_Base, BetterDataView_Error} from "./bdv_base.js"

export class BetterDataView extends BetterDataView_Base {
  _evalValue(valueString, object) { // usually used to get a size from a previous object key value
    return Function(`return ${valueString}`).bind(object)()
  }

  _parseTypeField(typeDefinition, object) {
    let arrayDimensions, type, size
    const s = typeDefinition.split(',') // split at each array-size-identifier
    const cIndex = s[0].indexOf(':')
    if (cIndex != -1) {
      type = s[0].slice(0,cIndex).trim().toLowerCase()
      size = s[0].slice(cIndex+1).trim()
      if (!(size in this)) { // if size doesn't precede the data (it checks if the size string is a type identifier)
        size = this._evalValue(size, object)
      }
    } else {
      type = s[0].trim().toLowerCase()
    }
    if (!(type in this)) {
      throw new BetterDataView_Error('Unknown type: '+type, 'TEMPLATE_ERROR')
    }
    if (s.length > 1) { // if array // todo: support 'whatever, u8, u8'
      arrayDimensions = s.slice(1)
      arrayDimensions.forEach((value,index) => {
        arrayDimensions[index] = this._evalValue(value, object)
      })
    }
    return {arrayDimensions, type, size}
  }

  /**
   * Read an object from the DataView. Instructions for parsing the binary data into an object must be defined in the supplied template.
   * @param {object} template - Parsing instructions. Check the documentation for "object templates".
   * @param {object} [parent]   - If this is a subobject and the template for it needs access to keys from the parent object then supply the parent object here.
   * @returns {Promise.<object>} The object read.
   */
  async readObject(template, parent) {
    if (typeof template != 'object') throw new BetterDataView_Error('You must supply a template for the object to be read', 'TEMPLATE_ERROR')

    const object = {} // the new object
    object._parent_ = parent
    for (const [tKey, tValue] of Object.entries(template)) {
      const assessAndReadType = async tValue => {
        let value
        if (typeof tValue == 'string') {
          if (tValue == 'undefined') return
          const readFunction = getReadFunction.call(this, tValue, object)
          value = await readFunction()
        } else if (Array.isArray(tValue)) {
          // todo: maybe support extensions here to allow cool things
          switch (tValue[0].toLowerCase()) {
            case 'string': {
              if (tValue.length != 2 || typeof tValue[1] != 'object') throw new BetterDataView_Error(`Correct definition is: ['string', {[lengthAs || length], encoding}]`, 'TEMPLATE_ERROR')
              const stringDetail = tValue[1]
              if (typeof stringDetail.encoding != 'string') throw new BetterDataView_Error('You must specify an encoding for the string', 'TEMPLATE_ERROR')
              let length // undefined == zero terminated string, 0 == no string
              if ('lengthAs' in stringDetail) {
                length = await this[stringDetail.lengthAs]()
              } else if ('length' in stringDetail) {
                length = typeof stringDetail.length == 'number' ? 
                  stringDetail.length : this._evalValue(stringDetail.length, object)
              }
              value = this.readString(length, stringDetail.encoding)
            } break
            case 'enum': {
              const enumMap = new Map(tValue[2])
              value = await assessAndReadType(tValue[1])
              value = enumMap.get(value) ?? value
            } break
            case 'bitfield':
              value = await this.readBitField(tValue[1])
            break
            case 'switch': {
              const switchMap = new Map(tValue[2])
              const switchQuery = this._evalValue(tValue[1], object)
              let switchResult = switchMap.get(switchQuery, object)
              if (switchResult == undefined && switchMap.has('_default_')) {
                switchResult = switchMap.get('_default_')
              }
              if (switchResult == undefined) throw new BetterDataView_Error("A switch case for '"+switchQuery+"' was not found and a _default_ case was not declared.", 'MISSING_CASE')
              value = await assessAndReadType(switchResult)
            } break
            case 'length':
            case 'size':
              value = await this[tValue[1].as]()
            break
            case 'list': {
              check_listDefinition(tValue)
              value = []
              let wantedDataSize, wantedLength
              let listDetail = {}
              if (tValue.length == 3) {
                listDetail = tValue[1]
                if ('lengthAs' in listDetail) {
                  wantedLength = await this[listDetail.lengthAs]()
                } else if ('size' in listDetail) { // e.g. ['list', {size: 2}, 'u8']
                  wantedDataSize = typeof listDetail.size == 'number' ? 
                    listDetail.size : this._evalValue(listDetail.size, object)
                } else if ('length' in listDetail) {
                  wantedLength = typeof listDetail.length == 'number' ? 
                    listDetail.length : this._evalValue(listDetail.length, object)
                }
                listDetail.valueDef = tValue[2]
              } else {
                listDetail.valueDef = tValue[1]
              }
              if (wantedDataSize) {
                const startPos = this.pos
                while (wantedDataSize > this.pos-startPos) {
                  value.push(await assessAndReadType(listDetail.valueDef))
                }
              } else if (wantedLength >= 0) {
                let length = 0
                while (length < wantedLength) {
                  value.push(await assessAndReadType(listDetail.valueDef))
                  length ++
                }
              } else { // else just read all we can (causes an error if rest of data doesn't match template)
                while (this.pos < this.byteLength) {
                  value.push(await assessAndReadType(listDetail.valueDef))
                }
              }
            } break
            case 'map': {
              check_mapDefinition(tValue)
              const keyReadFunction = getReadFunction.call(this, tValue[1].keyAs, object)
              const size = await this[tValue[1].sizeAs]()
              value = new Map()
              for (let i=0; i<size; i++) {
                value.set(await keyReadFunction(), await assessAndReadType(tValue[2]))
              }
            } break
            case 'set': {
              check_setDefinition(tValue)
              const size = await this[tValue[1].sizeAs]()
              value = new Set()
              for (let i=0; i<size; i++) {
                value.add(await assessAndReadType(tValue[2]))
              }
            } break
            default: throw new BetterDataView_Error('No such function: '+tValue[0], 'TEMPLATE_ERROR')
          }
        } else if (typeof tValue == 'object') {
          value = await this.readObject(tValue, object)
        }
        return value
      }
      try {
        const value = await assessAndReadType(tValue)
        if (value != undefined) object[tKey] = value
      } catch (error) {
        try {
          error.detail = `Last template definition before error:\n${tKey}: ${JSON.stringify(tValue,null,2)}`
            +'\nThe object so far:\n'+JSON.stringify(object,null,2)
        } catch {} // ignore stringify errors
        throw error
      }
    }
    delete object._parent_
    return object
  }

  /**
   * Writes an object into the DataView. Instructions for converting the object into binary data must be defined in the supplied template.
   * @param {object} template - Conversion instructions. Check the documentation for "object templates".
   * @param {object} object   - The object to write.   
   * @param {object} [parent]   - If this is a subobject and the template for it needs access to keys from the parent object then supply the parent object here.
   */
  async writeObject(template, object, parent) {
    if (typeof object != 'object') throw new BetterDataView_Error('Expected an object, got: '+typeof object+' ('+object+')', 'WRONG_TYPE')

    if (parent) {
      if (lastKeyDefined)
        currentObj = lastOffsets[lastKeyDefined] = {} // create the subobject
      else // e.g. if writeObject was called with a parent object to access data from it
        currentObj = lastOffsets = {} // clear any previous
    } else {
      currentObj = lastOffsets = {} // clear any previous
      lastKeyDefined = null
    }

    object._sizeBackWrites_ = new Map() // keep track of backwrites to do
    object._lengthBackWrites_ = new Map()
    object._parent_ = parent
    for (const [tKey, tValue] of Object.entries(template)) {
      const assessAndWriteType = async (tValue, oValue) => {
        if (typeof tValue == 'string') {
          if (tValue == 'undefined') return
          const writeFunction = getWriteFunction.call(this, tValue, object)
          await writeFunction(oValue)
        } else if (Array.isArray(tValue)) {
          switch (tValue[0].toLowerCase()) {
            case 'string': {
              if (tValue.length != 2 || typeof tValue[1] != 'object') throw new BetterDataView_Error(`Correct definition is: ['string', {[lengthAs || length], encoding}]`, 'TEMPLATE_ERROR')
              const stringDetail = tValue[1]
              if (typeof stringDetail.encoding != 'string') throw new BetterDataView_Error('You must specify an encoding for the string', 'TEMPLATE_ERROR')
              let lengthSpecified, zeroTerminated = true
              if ('lengthAs' in stringDetail) { // if string length is to be stored before the string
                zeroTerminated = false
                await this[stringDetail.lengthAs](oValue ? [...oValue].length : 0)
              } else if ('length' in stringDetail) { // if string length is read from template or a previous value
                zeroTerminated = false
                lengthSpecified = typeof stringDetail.length == 'number' ? 
                  stringDetail.length : this._evalValue(stringDetail.length, object)
                const strLength = oValue ? [...oValue].length : 0
                if (strLength > lengthSpecified) {
                  throw new BetterDataView_Error(`Asked to write a shorter (${lengthSpecified}) string than the one provided (${strLength}): `+oValue, 'SIZE_MISMATCH')
                } else if (strLength < lengthSpecified) {
                  throw new BetterDataView_Error(`Asked to write a longer (${lengthSpecified}) string than the one provided (${strLength}): `+oValue, 'SIZE_MISMATCH')
                }
              }
              // if there is a string to write or if it's empty and should be represented with a zero
              if (oValue || zeroTerminated) await this.writeString(oValue, zeroTerminated, stringDetail.encoding)
            } break
            case 'enum':
              const enumMap = new Map(tValue[2].map(e => [e[1],e[0]])) // switch key position
              const value = enumMap.get(oValue)
              if (value) { // if oValue matches enum string in the map
                await assessAndWriteType(tValue[1], value) // then convert it
              } else { // else it needs no conversion
                await assessAndWriteType(tValue[1], oValue)
              }
            break
            case 'bitfield':
              await this.writeBitField(tValue[1], oValue)
            break
            case 'switch': {
              const switchMap = new Map(tValue[2])
              const switchQuery = this._evalValue(tValue[1], object)
              let switchCase = switchMap.get(switchQuery)
              if (switchCase == undefined && switchMap.has('_default_')) {
                switchCase = switchMap.get('_default_')
              }
              if (switchCase == undefined) throw new BetterDataView_Error("A switch case for '"+switchQuery+"' was not found and a _default_ case was not declared.", 'MISSING_CASE')
              await assessAndWriteType(switchCase, oValue)
            } break
            case 'list': {
              check_listDefinition(tValue)
              let wantedDataSize, wantedLength
              let listDetail = {}
              if (tValue.length == 3) {
                listDetail = tValue[1]
                if ('lengthAs' in listDetail) { // e.g. ['list', {lengthAs: 'u16'}, 'u8']
                  await this[listDetail.lengthAs](oValue ? oValue.length : 0)
                } else if ('size' in listDetail) { // e.g. ['list', {size: 2}, 'u8']
                  wantedDataSize = typeof listDetail.size == 'number' ? 
                    listDetail.size : this._evalValue(listDetail.size, object)
                } else if ('length' in listDetail) {
                  wantedLength = typeof listDetail.length == 'number' ? 
                    listDetail.length : this._evalValue(listDetail.length, object)
                }
                listDetail.valueDef = tValue[2]
              } else {
                listDetail.valueDef = tValue[1]
              }
              let length = 0
              const startPos = this.pos
              if (oValue) {
                for (const element of oValue) {
                  length++
                  await assessAndWriteType(listDetail.valueDef, element)
                }
              }
              if (wantedDataSize && this.pos-startPos > wantedDataSize) {
                throw new BetterDataView_Error(`The specified list data size '${listDetail.size}' is less than the actual size of the data in the list: `+this.pos-startPos, 'SIZE_MISMATCH')
              }
              if (wantedLength && length > wantedLength) {
                throw new BetterDataView_Error(`The specified list length '${listDetail.size}' is less than the actual length of the list: `+length, 'SIZE_MISMATCH')
              }
              const backWrite = object._lengthBackWrites_.get(tKey)
              if (backWrite) { // if there is one for this key
                const currentPos = this.pos
                this.seek(backWrite.atPos)
                await backWrite.writeFunction(length)
                object[backWrite.key] = length
                this.seek(currentPos)
                object._lengthBackWrites_.delete(tKey)
              }
            } break
            case 'length': { // length of list
              object[tKey] = undefined // make sure it is set to undefined for now
              const size = tValue[1]
              object._lengthBackWrites_.set(size.of, {
                atPos: this.pos, 
                writeFunction: sizeToWrite => this[size.as](sizeToWrite),
                key: tKey // the key in the object, so we can write back the correct size in it as well
              })
              await this[size.as](0) // write something to progress this.pos the correct amount of bytes
            } break
            case 'size': { // byte-size of the value
              object[tKey] = undefined
              const size = tValue[1]
              object._sizeBackWrites_.set(size.of, {
                atPos: this.pos, 
                writeFunction: sizeToWrite => this[size.as](sizeToWrite),
                key: tKey
              })
              await this[size.as](0)
            } break
            case 'map': {
              check_mapDefinition(tValue)
              if (oValue) {
                const {sizeAs, keyAs} = tValue[1]
                const keyWriteFunction = getWriteFunction.call(this, keyAs, object)
                await this[sizeAs](oValue.size)
                for (const [key, value] of oValue) {
                  await keyWriteFunction(key)
                  await assessAndWriteType(tValue[2], value)
                }
              } else {
                await this[tValue[1].sizeAs](0)
              }
            } break
            case 'set': {
              check_setDefinition(tValue)
              if (oValue) {
                await this[tValue[1].sizeAs](oValue.size)
                for (const value of oValue) {
                  await assessAndWriteType(tValue[2], value)
                }
              } else {
                await this[tValue[1].sizeAs](0)
              }
            } break
            default: throw new BetterDataView_Error('No such function: '+tValue[0], 'TEMPLATE_ERROR')
          }
        } else if (typeof tValue == 'object') {
          await this.writeObject(tValue, oValue, object)
        }
      }
      try {
        const oValue = object[tKey]
        lastKeyDefined = tKey
        currentObj[lastKeyDefined] = this.pos // store offset of key in object
        const posBeforeWrite = this.pos // pos before value is written
        await assessAndWriteType(tValue, oValue)
        const bytesWritten = this.pos - posBeforeWrite
        const sizeBackWrite = object._sizeBackWrites_.get(tKey)
        if (sizeBackWrite) { // if there is one for this key
          this.seek(sizeBackWrite.atPos)
          await sizeBackWrite.writeFunction(bytesWritten)
          object[sizeBackWrite.key] = bytesWritten
          this.seek(posBeforeWrite+bytesWritten)
          object._sizeBackWrites_.delete(tKey)
        }
      } catch (error) {
        try {
          error.detail = `Last template definition before error:\n${tKey}: ${JSON.stringify(tValue,null,2)}`
        } catch {} // ignore stringify errors
        throw error
      }
    }
    delete object._parent_
    delete object._sizeBackWrites_
    delete object._lengthBackWrites_
  }

  /**
   * Evaluate the binary-size of an object without writing it. Instructions for converting the object into binary data must be defined in the supplied template.
   * @param {*} template - Conversion instructions. Check the documentation for "object templates".
   * @param {*} object - The object to evaluate.   
   * @param {*} [parent] - If this is a subobject and the template for it needs access to keys from the parent object then supply the parent object here.
   * @returns {number} The byte-size of the binary representation.
   */
  async objectSize(template, object, parent) { // eval size of object without writing it
    const startOffset = this.pos
    this._pretendToWrite = true
    await this.writeObject(template, object, parent)
    this._pretendToWrite = false
    this.pos = startOffset
    return this.pos - startOffset
  }
}

/**
 * An object containing the offsets of each value written in the last object by writeObject().
 */
// these 3 are for storing offsets of keys and subkeys of the last written object
export let lastOffsets
let lastKeyDefined, currentObj

const isIterable = object => object != null && typeof object[Symbol.iterator] == 'function'
function check_iterable(oValue) {
  if(!isIterable(oValue)) throw new BetterDataView_Error(
    "Template expected an array/iterable, but "
    +typeof oValue+" was given."+oValue, 'WRONG_TYPE'
  )
}
function check_listDefinition(tValue) {
  if (! (typeof tValue[1] == 'object' && tValue.length == 3 
  || tValue.length == 2))
    throw new BetterDataView_Error(`The correct definition for a list is ['list', {lengthAs} || {length} || {size}, valueDefinition] or ['list', valueDefinition].`, 'TEMPLATE_ERROR')
}
function check_mapDefinition(tValue) {
  if(! (typeof tValue[1] == 'object' && tValue.length == 3))
    throw new BetterDataView_Error(`The correct definition for a map is ['map', {sizeAs, keyAs}, valueDefinition].`, 'TEMPLATE_ERROR')
}
function check_setDefinition(tValue) {
  if(! (typeof tValue[1] == 'object' && tValue.length == 3))
    throw new BetterDataView_Error(`The correct definition for a set is ['set', {sizeAs}, valueDefinition].`, 'TEMPLATE_ERROR')
}

async function readArray(sizeArray, callback) {
  if (sizeArray.length) {
    const array = new Array(+sizeArray[0]) // + forces int conversion
    array.fill(null)
    for (let i=0; i<array.length; i++) {
      array[i] = await readArray(sizeArray.slice(1), callback)
    }
    return array
  }
  return await callback()
}
async function writeArray(sizeArray, array, callback) {
  if (sizeArray.length) {
    if (+sizeArray[0] != array.length) throw new BetterDataView_Error(
      "Template/object array size mismatch."
      +'\nExpected array of size '+sizeArray[0]
      +' got array of size '+array.length, 'SIZE_MISMATCH'
    )
    for (let i=0; i<+sizeArray[0]; i++) {
      await writeArray(sizeArray.slice(1), array[i], callback)
    }
    return
  }
  await callback(array)
}

function getReadFunction(tValue, object) {
  switch (typeof tValue) {
    case 'object':
    return () => this.readObject(tValue, object)
    case 'string': // if a type definition
      const {arrayDimensions, type, size} = this._parseTypeField(tValue, object)
      let readFunction
      switch (typeof size) {
        case 'string': // e.g. s:u8 instead of s:11 or s:this.strSize
          readFunction = () => this[type](this[size]()) // then read the size from the type that stored it
        break
        case 'undefined':
          readFunction = () => this[type]()
        break
        default:
          readFunction = () => this[type](size)
      }
      if (arrayDimensions) {
        const valueReadFunction = readFunction
        readFunction = () => readArray(arrayDimensions, valueReadFunction)
      }
    return readFunction
    default: throw new BetterDataView_Error('Invalid type definition, neither string nor object: '+tValue, 'TEMPLATE_ERROR')
  }
}
function getWriteFunction(tValue, object) {
  switch (typeof tValue) {
    case 'object': return value => this.writeObject(tValue, value, object)
    case 'string':
      let writeFunction
      const {arrayDimensions, type, size} = this._parseTypeField(tValue, object)
      switch (typeof size) {
        case 'string':
          switch (type) {
            case 's': 
              writeFunction = async string => {
                await this[size]([...string].length)
                await this[type](string, false)
              }
            break
            default: 
              writeFunction = async value => {
                const startOffset = this.pos
                await this[size](0) // write dummy size (to increase the write offset)
                const dataOffset = this.pos
                await this[type](value) 
                const dataSize = this.pos-dataOffset
                this.pos = startOffset
                await this[size](dataSize) // write detected size
                this.pos = dataOffset+dataSize // seek back to end of data
              }
          }
        break
        case 'undefined':
          writeFunction = value => this[type](value)
        break
        default:
          writeFunction = value => this[type](value, size)
      }
      if (arrayDimensions) {
        const valueWriteFunction = writeFunction
        writeFunction = value => {
          check_iterable(value)
          return writeArray(arrayDimensions, value, valueWriteFunction) // returns the write promise
        }
      }
    return writeFunction
    default: throw new BetterDataView_Error('Invalid type definition, neither string nor object: '+tValue, 'TEMPLATE_ERROR')
  }
}
